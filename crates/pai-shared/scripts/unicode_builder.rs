use std::{
    env,
    fmt::{self, Display},
    fs, io,
    iter::FromIterator,
    path::PathBuf,
    process::{Command, Output},
};

const BASE_UNICODE_UDC_URL: &str = "https://www.unicode.org/Public/UCD/latest/ucd/";
const README_TXT: &str = "ReadMe.txt";
const DERIVED_CORE_PROPERTIES_TXT: &str = "DerivedCoreProperties.txt";

const PROPERTIES: &[&str] = &["ID_Start", "ID_Continue"];

struct CodePointRange {
    lo: u32,
    hi: u32,
}

impl CodePointRange {
    pub fn parse_code_point(s: &str) -> u32 {
        let Ok(code_point) = u32::from_str_radix(s, 16) else {
            panic!("Parse: {s} is not valid u32")
        };

        if char::try_from(code_point).is_ok() {
            code_point
        } else {
            panic!("{code_point} is not char");
        }
    }

    pub fn new(lo: &str, hi: &str) -> Self {
        Self {
            lo: Self::parse_code_point(lo),
            hi: Self::parse_code_point(hi),
        }
    }
}

struct CodePointTable {
    contents: Vec<CodePointRange>,
}

impl FromIterator<CodePointRange> for CodePointTable {
    fn from_iter<T: IntoIterator<Item = CodePointRange>>(iter: T) -> Self {
        let mut table = Self {
            contents: Vec::new(),
        };

        for range @ CodePointRange { lo, hi } in iter {
            if let Some(prev) = table.contents.last_mut() {
                if prev.hi < lo && lo <= hi {
                    if lo - prev.hi == 1 {
                        prev.hi = hi
                    } else {
                        table.contents.push(range)
                    }
                } else {
                    panic!("Code point should be sorted for binary search")
                }
            } else {
                table.contents.push(range)
            }
        }

        table
    }
}

impl Display for CodePointTable {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        writeln!(f, "[")?;

        for CodePointRange { lo, hi } in &self.contents {
            writeln!(f, "    ('\\u{{{lo:04X}}}', '\\u{{{hi:04X}}}'),")?
        }

        write!(f, "]")
    }
}

pub struct UnicodeBuilder;

impl UnicodeBuilder {
    pub fn path(name: &str) -> PathBuf {
        let dir = env!("ENV_UNICODE_DIR");

        PathBuf::from(&format!("{dir}/{name}"))
    }

    pub fn fetch(name: &str) -> io::Result<String> {
        let url = format!("{BASE_UNICODE_UDC_URL}{name}");

        let Output {
            status,
            stdout,
            stderr,
        } = Command::new("curl").arg(url).output()?;

        if status.success() {
            Ok(unsafe { String::from_utf8_unchecked(stdout) })
        } else {
            panic!("{}", unsafe { std::str::from_utf8_unchecked(&stderr) })
        }
    }

    pub fn load(name: &str) -> io::Result<String> {
        let content = Self::fetch(name)?;

        let path = Self::path(name);

        fs::write(path, &content)?;

        Ok(content)
    }

    pub fn read(name: &str) -> io::Result<String> {
        let path = Self::path(name);

        let bytes = fs::read(path)?;

        Ok(unsafe { String::from_utf8_unchecked(bytes) })
    }

    pub fn generate_property_table(properties_text: &str, name: &str) -> io::Result<()> {
        let table: CodePointTable = properties_text
            .lines()
            .filter_map(|line| {
                // skip comment
                if line.chars().next()? == '#' {
                    return None
                }

                let (scalar, property) = line.split('#').next()?.split_once(';')?;

                if property.trim() == name {
                    Some(scalar.trim())
                } else {
                    None
                }
            })
            .map(|scalar| {
                match scalar.split_once("..") {
                    Some((lo, hi)) => CodePointRange::new(lo, hi),
                    None => CodePointRange::new(scalar, scalar),
                }
            })
            .collect();

        let source_code = format!(
            "// NOTE: This file is generated by build.rs, do not edit manually!\n\
             pub const {}: &[(char, char)] = &{};",
            name.to_uppercase(),
            table
        );

        let path = Self::path(&format!("{name}.rs"));

        fs::write(path, source_code)
    }

    pub fn generate_tables() -> io::Result<()> {
        if Self::path(README_TXT).exists() {
            let upstream_readme = Self::fetch(README_TXT)?;

            let local_readme = Self::read(README_TXT)?;

            if upstream_readme == local_readme {
                return Ok(())
            }
        }

        Self::load(README_TXT)?;

        let properties_text = Self::load(DERIVED_CORE_PROPERTIES_TXT)?;

        for property in PROPERTIES {
            Self::generate_property_table(&properties_text, property)?;
        }

        Ok(())
    }
}
